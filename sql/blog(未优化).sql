/*
 Navicat Premium Data Transfer

 Source Server         : localhost - MySQL8.0
 Source Server Type    : MySQL
 Source Server Version : 80022
 Source Host           : localhost:3306
 Source Schema         : blog_02

 Target Server Type    : MySQL
 Target Server Version : 80022
 File Encoding         : 65001

 Date: 18/06/2021 01:00:49
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `article_id` int NOT NULL AUTO_INCREMENT,
  `article_user_id` int UNSIGNED NULL DEFAULT 1,
  `article_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `markdown_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `html_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_view_count` int NULL DEFAULT 0,
  `article_comment_count` int NULL DEFAULT 0,
  `article_like_count` int NULL DEFAULT 0,
  `article_type` int UNSIGNED NULL DEFAULT 1,
  `issue_type` int UNSIGNED NULL DEFAULT 1,
  `article_update_time` datetime(0) NULL DEFAULT NULL,
  `article_create_time` datetime(0) NULL DEFAULT NULL,
  `article_image` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '\\static\\pic\\default.jpg',
  PRIMARY KEY (`article_id`) USING BTREE,
  INDEX `article_user_id`(`article_user_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 204 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (16, 1, 'Java知识——IO流操作', '# 基本概念\r\n　　Java中对文件的操作是以流的方式进行的。流是Java内存中的一组有序数据序列。Java将数据从源（文件、内存、键盘、网络）\r\n 读入到内存中，形成了流，然后将这些流还可以写到另外的目的地（文件、内存、控制台、网络），之所以称为流，是因为这个数据序列在不同时刻所操作的是源的不同部分。\r\n# 流的分类\r\n　　流的分类，Java的流分类比较丰富，刚接触的人看了后会感觉很晕。流分类的方式很多：\r\n　　1、按照输入的方向分，输入流和输出流，输入输出的参照对象是Java程序。\r\n　　2、按照处理数据的单位不同分，字节流和字符流，字节流读取的最小单位是一个字节（1byte=8bit），而字符流一次可以读取一个字符（1char = 2byte = 16bit）。\r\n　　3、按照功能的不同分，分节点流和处理流，节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的一种流，FileInputStream\r\n 是一个接点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能。\r\n　　其实除了以上三种分类外，还有一些常常听到的一些分类比如：对象流、缓冲流、压缩流、文件流等等。其实都是节点流和处理流的子分类。当然你也可以创建新的流类型，只要你需要。\r\n# 关系\r\n　　不管流的分类是多么的丰富和复杂，其根源来自于四个基本的类。这个四个类的关系如下：\r\n　　   字节流  字符流\r\n　　输入流  InputStream  Reader\r\n　　输出流  OutputStream  Writer\r\n　　<!-- EndFragment-->\r\n# 字节流和字符流的相互转换\r\n　　1、从字节流到字符流：InputStreamReader、OutputStreamWriter类可以实现。\r\n　　2、从字符流到字节流：可以从字符流中获取char[]数组，转换为String，然后调用String的API函数getBytes() 获取到byte[]，然后就可以通过ByteArrayInputStream、\r\n ByteArrayOutputStream来实现到字节流的转换。\r\n# 实例\r\n附加：除了使用inputStreamreader和writer来将流转换为字符串意外还可以：\r\n```\r\ninputSteam in=。。\r\nByteArrayOutputStream outputStream=new ByteArrayOutputStream();\r\nbyte[] data=new byte[1024];\r\nint len=0;\r\nwhile((len=in.read(buffer))!=-1){\r\n    outputStream.write(data,0,len);\r\n}\r\nbyte[]data_b=outputStream.toByteArray();//转化为字节数组\r\nString data_s=new String(data,\"utf-8\");//转化为字符串\r\n```\r\n```\r\nFileInputStream in=openFileInput(\"文件名\")//InputStream in=connection.getInputStream();//读取文件和网络返回得数据\r\nInputStream in=xx.getInputStream();\r\nBufferedReader reader=new BufferedReader(new InputStreamReader(in));//使用inputstreamreader将字节转化为字符\r\nwhile(reader.readLine()!=null){\r\n    StringBuilder sb=new StringBuilder();//使用stringbuilder组装效率更高\r\n    sb.append(reader.readLine());\r\n}\r\n```\r\n```\r\nFileOutputStream out =openFileOutput(\"文件名\",文件操作模式);\r\nBufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));//先转换成了字符型在调用了缓冲字符输出流\r\nwriter.write(data);\r\n```\r\n\r\n------------\r\n\r\n', '<h1 id=\"h1-u57FAu672Cu6982u5FF5\"><a name=\"基本概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本概念</h1><p>　　Java中对文件的操作是以流的方式进行的。流是Java内存中的一组有序数据序列。Java将数据从源（文件、内存、键盘、网络）<br> 读入到内存中，形成了流，然后将这些流还可以写到另外的目的地（文件、内存、控制台、网络），之所以称为流，是因为这个数据序列在不同时刻所操作的是源的不同部分。</p>\r\n<h1 id=\"h1-u6D41u7684u5206u7C7B\"><a name=\"流的分类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>流的分类</h1><p>　　流的分类，Java的流分类比较丰富，刚接触的人看了后会感觉很晕。流分类的方式很多：<br>　　1、按照输入的方向分，输入流和输出流，输入输出的参照对象是Java程序。<br>　　2、按照处理数据的单位不同分，字节流和字符流，字节流读取的最小单位是一个字节（1byte=8bit），而字符流一次可以读取一个字符（1char = 2byte = 16bit）。<br>　　3、按照功能的不同分，分节点流和处理流，节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的一种流，FileInputStream<br> 是一个接点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能。<br>　　其实除了以上三种分类外，还有一些常常听到的一些分类比如：对象流、缓冲流、压缩流、文件流等等。其实都是节点流和处理流的子分类。当然你也可以创建新的流类型，只要你需要。</p>\r\n<h1 id=\"h1-u5173u7CFB\"><a name=\"关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关系</h1><p>　　不管流的分类是多么的丰富和复杂，其根源来自于四个基本的类。这个四个类的关系如下：<br>　　   字节流  字符流<br>　　输入流  InputStream  Reader<br>　　输出流  OutputStream  Writer<br>　　&lt;!-- EndFragment--&gt;</p>\r\n<h1 id=\"h1-u5B57u8282u6D41u548Cu5B57u7B26u6D41u7684u76F8u4E92u8F6Cu6362\"><a name=\"字节流和字符流的相互转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>字节流和字符流的相互转换</h1><p>　　1、从字节流到字符流：InputStreamReader、OutputStreamWriter类可以实现。<br>　　2、从字符流到字节流：可以从字符流中获取char[]数组，转换为String，然后调用String的API函数getBytes() 获取到byte[]，然后就可以通过ByteArrayInputStream、<br> ByteArrayOutputStream来实现到字节流的转换。</p>\r\n<h1 id=\"h1-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h1><p>附加：除了使用inputStreamreader和writer来将流转换为字符串意外还可以：</p>\r\n<pre><code>inputSteam in=。。\r\nByteArrayOutputStream outputStream=new ByteArrayOutputStream();\r\nbyte[] data=new byte[1024];\r\nint len=0;\r\nwhile((len=in.read(buffer))!=-1){\r\n    outputStream.write(data,0,len);\r\n}\r\nbyte[]data_b=outputStream.toByteArray();//转化为字节数组\r\nString data_s=new String(data,&quot;utf-8&quot;);//转化为字符串\r\n</code></pre><pre><code>FileInputStream in=openFileInput(&quot;文件名&quot;)//InputStream in=connection.getInputStream();//读取文件和网络返回得数据\r\nInputStream in=xx.getInputStream();\r\nBufferedReader reader=new BufferedReader(new InputStreamReader(in));//使用inputstreamreader将字节转化为字符\r\nwhile(reader.readLine()!=null){\r\n    StringBuilder sb=new StringBuilder();//使用stringbuilder组装效率更高\r\n    sb.append(reader.readLine());\r\n}\r\n</code></pre><pre><code>FileOutputStream out =openFileOutput(&quot;文件名&quot;,文件操作模式);\r\nBufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));//先转换成了字符型在调用了缓冲字符输出流\r\nwriter.write(data);\r\n</code></pre><hr>\r\n', 8, 0, 0, 1, 1, '2021-06-08 20:45:22', '2021-06-08 16:04:25', '\\static\\bgpic\\default.png');
INSERT INTO `article` VALUES (17, 1, 'Java总结篇系列：Java多线程（一）', '多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。\r\n# 线程的生命周期及五种基本状态\r\n关于Java中线程的生命周期，首先看一下下面这张较为经典的图：\r\n![](/Blog/static/pic/1554814153183.jpg)\r\n上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：\r\n## Java线程具有五中基本状态\r\n**新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\r\n\r\n**就绪状态（Runnable）**：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\r\n\r\n**运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\r\n\r\n**阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\r\n\r\n1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\r\n\r\n2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\r\n\r\n3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\r\n\r\n**死亡状态（Dead）**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\r\n\r\n# Java多线程的创建及启动\r\n\r\nJava中线程的创建常见有如三种基本形式\r\n**1.继承Thread类，重写该类的run()方法。**\r\n```\r\nclass MyThread extends Thread {\r\n    \r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\r\n                Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\r\n                myThread1.start();                     // 调用start()方法使得线程进入就绪状态\r\n                myThread2.start();                     // 调用start()方法使得线程进入就绪状态\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。\r\n\r\n**2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。**\r\n```\r\nclass MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\r\n                Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\r\n                Thread thread2 = new Thread(myRunnable);\r\n                thread1.start(); // 调用start()方法使得线程进入就绪状态\r\n                thread2.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable();\r\n                Thread thread = new MyThread(myRunnable);\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"in MyRunnable run\");\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n\r\nclass MyThread extends Thread {\r\n\r\n    private int i = 0;\r\n    \r\n    public MyThread(Runnable runnable){\r\n        super(runnable);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"in MyThread run\");\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n同样的，与实现Runnable接口创建线程方式相似，不同的地方在于\r\n\r\n`Thread thread = new MyThread(myRunnable);`\r\n\r\n那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。\r\n\r\n**3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程**\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Callable<Integer> myCallable = new MyCallable();    // 创建MyCallable对象\r\n        FutureTask<Integer> ft = new FutureTask<Integer>(myCallable); //使用FutureTask来包装MyCallable对象\r\n\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Thread thread = new Thread(ft);   //FutureTask对象作为Thread对象的target创建新的线程\r\n                thread.start();                      //线程进入到就绪状态\r\n            }\r\n        }\r\n\r\n        System.out.println(\"主线程for循环执行完毕..\");\r\n        \r\n        try {\r\n            int sum = ft.get();            //取得新创建的新线程中的call()方法返回的结果\r\n            System.out.println(\"sum = \" + sum);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nclass MyCallable implements Callable<Integer> {\r\n    private int i = 0;\r\n\r\n    // 与run()方法不同的是，call()方法具有返回值\r\n    @Override\r\n    public Integer call() {\r\n        int sum = 0;\r\n        for (; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            sum += i;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\r\n```\r\n首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义：\r\n```\r\n public class FutureTask<V> implements RunnableFuture<V> {\r\n     \r\n   //....\r\n     \r\n }\r\n```\r\n于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。\r\n\r\n执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？\r\n\r\n原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。\r\n\r\n上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：**不能对同一线程对象两次调用start()方法。**\r\n# 三. Java多线程的就绪、运行和死亡状态\r\n就绪状态转换为运行状态：当此线程得到处理器资源；\r\n\r\n运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。\r\n\r\n运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。\r\n\r\n此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。\r\n\r\n由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如：\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        MyRunnable myRunnable = new MyRunnable();\r\n        Thread thread = new Thread(myRunnable);\r\n        \r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                thread.start();\r\n            }\r\n            if(i == 40){\r\n                myRunnable.stopThread();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n\r\n    private boolean stop;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 100 && !stop; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n\r\n    public void stopThread() {\r\n        this.stop = true;\r\n    }\r\n\r\n}\r\n```\r\n\r\n------------\r\n\r\n', '<p>多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。</p>\r\n<h1 id=\"h1-u7EBFu7A0Bu7684u751Fu547Du5468u671Fu53CAu4E94u79CDu57FAu672Cu72B6u6001\"><a name=\"线程的生命周期及五种基本状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程的生命周期及五种基本状态</h1><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：<br><img src=\"/Blog/static/pic/1554814153183.jpg\" alt=\"\"><br>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p>\r\n<h2 id=\"h2-java-\"><a name=\"Java线程具有五中基本状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java线程具有五中基本状态</h2><p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>\r\n<p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>\r\n<p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>\r\n<p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>\r\n<p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>\r\n<p>2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>\r\n<p>3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>\r\n<p><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>\r\n<h1 id=\"h1-java-\"><a name=\"Java多线程的创建及启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java多线程的创建及启动</h1><p>Java中线程的创建常见有如三种基本形式<br><strong>1.继承Thread类，重写该类的run()方法。</strong></p>\r\n<pre><code>class MyThread extends Thread {\r\n\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n</code></pre><pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\r\n                Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\r\n                myThread1.start();                     // 调用start()方法使得线程进入就绪状态\r\n                myThread2.start();                     // 调用start()方法使得线程进入就绪状态\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。</p>\r\n<p><strong>2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。</strong></p>\r\n<pre><code>class MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n</code></pre><pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\r\n                Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\r\n                Thread thread2 = new Thread(myRunnable);\r\n                thread1.start(); // 调用start()方法使得线程进入就绪状态\r\n                thread2.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。</p>\r\n<pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable();\r\n                Thread thread = new MyThread(myRunnable);\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(&quot;in MyRunnable run&quot;);\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n\r\nclass MyThread extends Thread {\r\n\r\n    private int i = 0;\r\n\r\n    public MyThread(Runnable runnable){\r\n        super(runnable);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(&quot;in MyThread run&quot;);\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n</code></pre><p>同样的，与实现Runnable接口创建线程方式相似，不同的地方在于</p>\r\n<p><code>Thread thread = new MyThread(myRunnable);</code></p>\r\n<p>那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。</p>\r\n<p><strong>3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程</strong></p>\r\n<pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Callable&lt;Integer&gt; myCallable = new MyCallable();    // 创建MyCallable对象\r\n        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象\r\n\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Thread thread = new Thread(ft);   //FutureTask对象作为Thread对象的target创建新的线程\r\n                thread.start();                      //线程进入到就绪状态\r\n            }\r\n        }\r\n\r\n        System.out.println(&quot;主线程for循环执行完毕..&quot;);\r\n\r\n        try {\r\n            int sum = ft.get();            //取得新创建的新线程中的call()方法返回的结果\r\n            System.out.println(&quot;sum = &quot; + sum);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nclass MyCallable implements Callable&lt;Integer&gt; {\r\n    private int i = 0;\r\n\r\n    // 与run()方法不同的是，call()方法具有返回值\r\n    @Override\r\n    public Integer call() {\r\n        int sum = 0;\r\n        for (; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            sum += i;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\r\n</code></pre><p>首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义：</p>\r\n<pre><code> public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {\r\n\r\n   //....\r\n\r\n }\r\n</code></pre><p>于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。</p>\r\n<p>执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？</p>\r\n<p>原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。</p>\r\n<p>上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：<strong>不能对同一线程对象两次调用start()方法。</strong></p>\r\n<h1 id=\"h1--java-\"><a name=\"三. Java多线程的就绪、运行和死亡状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三. Java多线程的就绪、运行和死亡状态</h1><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p>\r\n<p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p>\r\n<p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p>\r\n<p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p>\r\n<p>由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如：</p>\r\n<pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        MyRunnable myRunnable = new MyRunnable();\r\n        Thread thread = new Thread(myRunnable);\r\n\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                thread.start();\r\n            }\r\n            if(i == 40){\r\n                myRunnable.stopThread();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n\r\n    private boolean stop;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i &lt; 100 &amp;&amp; !stop; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n\r\n    public void stopThread() {\r\n        this.stop = true;\r\n    }\r\n\r\n}\r\n</code></pre><hr>\r\n', 16, 0, 0, 1, 1, '2021-06-08 20:49:16', '2021-06-08 16:05:55', '\\static\\bgpic\\default.png');
INSERT INTO `article` VALUES (28, 1, 'Linux常用的命令', '# 前言\r\n主要用来介绍一些长用的Linux命令\r\ntaskkill -f -im .exe    结束进程\r\ntasklist                查看进程\r\nslmgr.vbs               查看WINDOWS\r\nckeanmgr/sageset:1      清理磁盘\r\nformat f:/q             格式化磁盘\r\nvol f:                  查看磁盘\r\nconvert f:/fs:ntfs      FAT32转化为ntfs\r\nshutdown -s -t          关机\r\nnetstat   -ano|findstr  8080  查看端口8080被哪个pid给占用\r\ntaskkill  -pid  6856  -f  清理pid为6856掉进程\r\n\r\ndir mulu /s 列出目录大小\r\ndxdiag  查询电脑配置\r\n\r\n\r\nmaven:\r\n	src\r\n		-main\r\n			-java\r\n				-package\r\n		-test\r\n			-java\r\n				-package\r\n	resources\r\n	mvn -v查看版本\r\n	compile 编译\r\n	test 测试\r\n	package 打包\r\n	clean 删除target\r\n	install安装jar包到本地仓库中\r\n	创建目录\r\n	archetype:generate\r\n\r\n\r\nclean 清理项目\r\ndefault构建项目\r\nsite 生成项目站点\r\nmaven生命周期 clean,compile(编译),test(测试),package(打包，打包时依次执行编译和测试),install\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>主要用来介绍一些长用的Linux命令<br>taskkill -f -im .exe    结束进程<br>tasklist                查看进程<br>slmgr.vbs               查看WINDOWS<br>ckeanmgr/sageset:1      清理磁盘<br>format f:/q             格式化磁盘<br>vol f:                  查看磁盘<br>convert f:/fs:ntfs      FAT32转化为ntfs<br>shutdown -s -t          关机<br>netstat   -ano|findstr  8080  查看端口8080被哪个pid给占用<br>taskkill  -pid  6856  -f  清理pid为6856掉进程</p>\r\n<p>dir mulu /s 列出目录大小<br>dxdiag  查询电脑配置</p>\r\n<p>maven:<br>    src<br>        -main<br>            -java<br>                -package<br>        -test<br>            -java<br>                -package<br>    resources<br>    mvn -v查看版本<br>    compile 编译<br>    test 测试<br>    package 打包<br>    clean 删除target<br>    install安装jar包到本地仓库中<br>    创建目录<br>    archetype:generate</p>\r\n<p>clean 清理项目<br>default构建项目<br>site 生成项目站点<br>maven生命周期 clean,compile(编译),test(测试),package(打包，打包时依次执行编译和测试),install</p>\r\n', 7, 0, 0, 1, 1, '2021-06-09 14:13:12', '2021-06-08 20:58:22', '\\static\\bgpic\\default.png');
INSERT INTO `article` VALUES (29, 1, 'Git上传本地项目以及修改', '# 前言\r\n本文主要用来介绍Git上传自己的项目到github上，以及当修改github项目。\r\n# 第一步\r\n   我们需要先创建一个本地的版本库（其实也就是一个文件夹）。\r\n你可以直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建。\r\n![](/Blog/static/pic/1554803406981.png)\r\n现在我通过命令行在桌面新建一个TEST文件夹（你也可以在其他任何地方创建这个文件夹），并且进入这个文件夹\r\n![](/Blog/static/pic/1554803413243.png)\r\n\r\n#   第二步\r\n通过命令git init把这个文件夹变成Git可管理的仓库\r\n  ![](/Blog/static/pic/1554803430257.png)\r\n  \r\n   这时你会发现TEST里面多了个.git文件夹，它是Git用来跟踪和管理版本库的。如果你看不到，是因为它默认是隐藏文件，那你就需要设置一下让隐藏文件可见。\r\n![](/Blog/static/pic/1554803448571.png)\r\n   \r\n# 第三步\r\n这时候你就可以把你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态），然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态。\r\n![](/Blog/static/pic/1554803613139.png)\r\n\r\n这里提示你虽然把项目粘贴过来了，但还没有add到Git仓库上，然后我们通过git add .把刚才复制过来的项目全部添加到仓库上。\r\n![](/Blog/static/pic/1554803639105.png)\r\n\r\n查看当前的git状态\r\n![](/Blog/static/pic/1554803671964.png)\r\n\r\n#  第四步\r\n 用git commit把项目提交到仓库。\r\n \r\n ![](/Blog/static/pic/1554803693751.png)\r\n \r\n  **-m**后面引号里面是本次提交的注释内容，这个可以不写，但最好写上，不然会报错，详情自行Google。 好了，我们本地Git仓库这边的工作做完了，下面就到了连接远程仓库（也就是连接Github）\r\n 由于本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下。\r\n \r\n#  第五步\r\n创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建\r\n`\r\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\r\n`\r\n然后一路回车。这时你就会在用户下的.ssh目录里找到id_rsa和id_rsa.pub这两个文件   \r\n![](/Blog/static/pic/1554803811593.png)\r\n\r\n#   第六步\r\n登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。具体步骤也可看下面：\r\n![](/Blog/static/pic/1554803845547.png)\r\n![](/Blog/static/pic/1554803891121.png)\r\n![](/Blog/static/pic/1554803906152.png)\r\n![](/Blog/static/pic/1554803917717.png)\r\n\r\n#  第七步\r\n在Github上创建一个Git仓库。\r\n\r\n 你可以直接点New repository来创建，比如我创建了一个TEST2的仓库（因为我里面已经有了一个test的仓库，所以不能再创建TEST仓库）。\r\n ![](/Blog/static/pic/1554803967085.png)\r\n \r\n#  第八步\r\n\r\n在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地TEST仓库的命令行输入：\r\n\r\n`$ git remote add origin https://github.com/guyibang/TEST2.git`\r\n\r\n![](/Blog/static/pic/1554804023151.png)\r\n\r\n 注意origin后面加的是你Github上创建好的仓库的地址。\r\n \r\n ![](/Blog/static/pic/1554804043581.png)\r\n \r\n#   第九步\r\n\r\n关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过：\r\n\r\n`$ git push -u origin master`\r\n\r\n  由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：\r\n  \r\n`  $ git push origin master`\r\n\r\n 上传项目的过程可能需要等一段时间，完成之后是这样的：\r\n ![](/Blog/static/pic/1554804164220.png)\r\n \r\n   这时候你再重新刷新你的Github页面进入刚才新建的那个仓库里面就会发现项目已经成功上传了：\r\n   \r\n   ![](/Blog/static/pic/1554804193426.png)\r\n   \r\n至此就完成了将本地项目上传到Github的整个过程。\r\n另外，这里有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to github.com/guyibang/Test.git\r\n\r\n![](/Blog/static/pic/1554804313627.png)\r\n\r\n   这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：\r\n   \r\n`$ git pull --rebase origin master`\r\n![](/Blog/static/pic/1554804366856.png)\r\n\r\n  这时你再push就能成功了。\r\n#   删除已经上传好的文件夹\r\n1. 在你的本地目录下手动删除你要删除的东西\r\n2. 在客户端输入：git commit -a -m \"A file was deleted\"\r\n3. 在客户端：git push\r\n4. 在客户端输入你的用户名和密码\r\n5. 如果有一下情况需要进行合并\r\n\r\n### 提交删除\r\n![](/Blog/static/pic/1554804453876.png)\r\n\r\n### 合并分支\r\n` git pull origin master`\r\n\r\n![](/Blog/static/pic/1554804594167.png)\r\n\r\n### 上传\r\n\r\n`Git push`\r\n\r\n![](/Blog/static/pic/1554804627758.png)\r\n\r\n退出蓝色框输入 `:wq`\r\n\r\n------------\r\n\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>本文主要用来介绍Git上传自己的项目到github上，以及当修改github项目。</p>\r\n<h1 id=\"h1-u7B2Cu4E00u6B65\"><a name=\"第一步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第一步</h1><p>   我们需要先创建一个本地的版本库（其实也就是一个文件夹）。<br>你可以直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建。<br><img src=\"/Blog/static/pic/1554803406981.png\" alt=\"\"><br>现在我通过命令行在桌面新建一个TEST文件夹（你也可以在其他任何地方创建这个文件夹），并且进入这个文件夹<br><img src=\"/Blog/static/pic/1554803413243.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E8Cu6B65\"><a name=\"第二步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第二步</h1><p>通过命令git init把这个文件夹变成Git可管理的仓库<br>  <img src=\"/Blog/static/pic/1554803430257.png\" alt=\"\"></p>\r\n<p>   这时你会发现TEST里面多了个.git文件夹，它是Git用来跟踪和管理版本库的。如果你看不到，是因为它默认是隐藏文件，那你就需要设置一下让隐藏文件可见。<br><img src=\"/Blog/static/pic/1554803448571.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E09u6B65\"><a name=\"第三步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第三步</h1><p>这时候你就可以把你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态），然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态。<br><img src=\"/Blog/static/pic/1554803613139.png\" alt=\"\"></p>\r\n<p>这里提示你虽然把项目粘贴过来了，但还没有add到Git仓库上，然后我们通过git add .把刚才复制过来的项目全部添加到仓库上。<br><img src=\"/Blog/static/pic/1554803639105.png\" alt=\"\"></p>\r\n<p>查看当前的git状态<br><img src=\"/Blog/static/pic/1554803671964.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu56DBu6B65\"><a name=\"第四步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第四步</h1><p> 用git commit把项目提交到仓库。</p>\r\n<p> <img src=\"/Blog/static/pic/1554803693751.png\" alt=\"\"></p>\r\n<p>  <strong>-m</strong>后面引号里面是本次提交的注释内容，这个可以不写，但最好写上，不然会报错，详情自行Google。 好了，我们本地Git仓库这边的工作做完了，下面就到了连接远程仓库（也就是连接Github）<br> 由于本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下。</p>\r\n<h1 id=\"h1-u7B2Cu4E94u6B65\"><a name=\"第五步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第五步</h1><p>创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建<br><code>$ ssh-keygen -t rsa -C &quot;<a href=\"mailto:youremail@example.com\">youremail@example.com</a>&quot;</code><br>然后一路回车。这时你就会在用户下的.ssh目录里找到id_rsa和id_rsa.pub这两个文件<br><img src=\"/Blog/static/pic/1554803811593.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu516Du6B65\"><a name=\"第六步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第六步</h1><p>登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。具体步骤也可看下面：<br><img src=\"/Blog/static/pic/1554803845547.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554803891121.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554803906152.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554803917717.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E03u6B65\"><a name=\"第七步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第七步</h1><p>在Github上创建一个Git仓库。</p>\r\n<p> 你可以直接点New repository来创建，比如我创建了一个TEST2的仓库（因为我里面已经有了一个test的仓库，所以不能再创建TEST仓库）。<br> <img src=\"/Blog/static/pic/1554803967085.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu516Bu6B65\"><a name=\"第八步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第八步</h1><p>在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地TEST仓库的命令行输入：</p>\r\n<p><code>$ git remote add origin https://github.com/guyibang/TEST2.git</code></p>\r\n<p><img src=\"/Blog/static/pic/1554804023151.png\" alt=\"\"></p>\r\n<p> 注意origin后面加的是你Github上创建好的仓库的地址。</p>\r\n<p> <img src=\"/Blog/static/pic/1554804043581.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E5Du6B65\"><a name=\"第九步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第九步</h1><p>关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过：</p>\r\n<p><code>$ git push -u origin master</code></p>\r\n<p>  由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：</p>\r\n<p><code>$ git push origin master</code></p>\r\n<p> 上传项目的过程可能需要等一段时间，完成之后是这样的：<br> <img src=\"/Blog/static/pic/1554804164220.png\" alt=\"\"></p>\r\n<p>   这时候你再重新刷新你的Github页面进入刚才新建的那个仓库里面就会发现项目已经成功上传了：</p>\r\n<p>   <img src=\"/Blog/static/pic/1554804193426.png\" alt=\"\"></p>\r\n<p>至此就完成了将本地项目上传到Github的整个过程。<br>另外，这里有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to github.com/guyibang/Test.git</p>\r\n<p><img src=\"/Blog/static/pic/1554804313627.png\" alt=\"\"></p>\r\n<p>   这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：</p>\r\n<p><code>$ git pull --rebase origin master</code><br><img src=\"/Blog/static/pic/1554804366856.png\" alt=\"\"></p>\r\n<p>  这时你再push就能成功了。</p>\r\n<h1 id=\"h1-u5220u9664u5DF2u7ECFu4E0Au4F20u597Du7684u6587u4EF6u5939\"><a name=\"删除已经上传好的文件夹\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除已经上传好的文件夹</h1><ol>\r\n<li>在你的本地目录下手动删除你要删除的东西</li><li>在客户端输入：git commit -a -m “A file was deleted”</li><li>在客户端：git push</li><li>在客户端输入你的用户名和密码</li><li>如果有一下情况需要进行合并</li></ol>\r\n<h3 id=\"h3-u63D0u4EA4u5220u9664\"><a name=\"提交删除\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>提交删除</h3><p><img src=\"/Blog/static/pic/1554804453876.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u5408u5E76u5206u652F\"><a name=\"合并分支\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>合并分支</h3><p><code>git pull origin master</code></p>\r\n<p><img src=\"/Blog/static/pic/1554804594167.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u4E0Au4F20\"><a name=\"上传\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>上传</h3><p><code>Git push</code></p>\r\n<p><img src=\"/Blog/static/pic/1554804627758.png\" alt=\"\"></p>\r\n<p>退出蓝色框输入 <code>:wq</code></p>\r\n<hr>\r\n', 10, 0, 0, 1, 1, '2021-06-09 14:15:21', '2021-06-08 21:00:24', '\\static\\bgpic\\default.png');
INSERT INTO `article` VALUES (30, 1, 'Juqery的一些插件', '# VueJS表头固定的数据表格 可按每列排序\r\n\r\n在网页中，表格（table）大部分用于数据的展示和处理，在jQuery的时代，用于表格的插件非常多。今天我们介绍一个基于VueJS的表格应用，它的特点是表格表头固定，也就是说当表格数据行很多时，页面下拉时表头可以固定，方便查看每一列的数据。另外还有特点是我们可以对每一个列进行排序。同时，这款JS表格的外观也不错，可以很好用到你的项目中。VueJS还是挺灵活的。\r\n![](/Blog/static/pic/1554802177854.png)\r\n链接：[https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar](https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar \"https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar\")\r\n\r\n# 基于Three.js和HTML5 Canvas的3D水晶球体\r\n今天给大家分享一个很酷的HTML5 Canvas 3D动画，它同样是一个基于Three.js制作的动画特效。在Canvas上有一个用许多长度各异的水晶柱形组成的球体，我们还可以用鼠标拖拽球体来从不同角度观察球面，还可以用鼠标滚轮来缩放球面。还有一个特性就是，双击球面可以改变水晶面的颜色，同时水晶面上会随着旋转的角度出现亮光，更加凸显出其3D立体的视觉效果。\r\n![](/Blog/static/pic/1554802278738.png)\r\n链接:\r\n[https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar](https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar \"https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar\")\r\n\r\n# HTML5 Emoji自定义表情编辑器\r\nEmoji表情在网页中使用十分广泛，它由一些简单的字符组成许多表情，例如笑脸、蛋糕等。今天我们要介绍一个基于HTML5和CSS3的Emoji自定义表情编辑器，初始默认是一个人脸，你可以在编辑器中为该人脸表情添加和改变各种面部表情，例如带上帽子，噘嘴等，甚至可以将其他任意Emoji表情添加上去，用起来非常不错。但是如果可以将编辑好的表情导出就更加完美了。\r\n![](/Blog/static/pic/1554802322011.png)\r\n链接:\r\n[https://www.html5tricks.com/download/html5-emoji-editor.rar](https://www.html5tricks.com/download/html5-emoji-editor.rar \"https://www.html5tricks.com/download/html5-emoji-editor.rar\")\r\n\r\n# HTML5和CSS3实现的自定义3D滑杆控件\r\n之前我们分享过一些比较有意思的滑杆控件，比如这款基于VueJS的滑块组件就非常不错。滑杆这种控件一般用在范围选取上面，比如结合图表生成一定范围的数据。今天我们分享的这个滑杆控件自定义程度非常高，特别是使用了CSS3的3D特性，让整一个滑杆控件效果更加炫酷。\r\n![](/Blog/static/pic/1554802370966.png)\r\n链接:\r\n[https://www.html5tricks.com/download/html5-css3-3d-slider.rar](https://www.html5tricks.com/download/html5-css3-3d-slider.rar \"https://www.html5tricks.com/download/html5-css3-3d-slider.rar\")\r\n\r\n# CSS3和SVG实现的圆环菜单动画\r\n网页菜单的样式真实多种多样，特别是HTML5和CSS3的流行，让网页菜单的外观更加丰富多彩了。今天我们要给大家分享一个基于CSS3和SVG的圆环形状的菜单，在圆环上一共有7个节点，表示菜单项，当鼠标滑过或者点击其中一个节点时，就会弹出文字菜单项，圆环形状和节点都是采用SVG绘制而成，动画效果也非常不错。\r\n![](/Blog/static/pic/1554802423628.png)\r\n链接:\r\n[https://www.html5tricks.com/download/css3-svg-circle-menu.rar](https://www.html5tricks.com/download/css3-svg-circle-menu.rar \"https://www.html5tricks.com/download/css3-svg-circle-menu.rar\")\r\n\r\n# 超酷的CSS3复古风格和字体的3D按钮\r\n我们分享过很多基于CSS3的3D按钮，很多都非常漂亮，例如这篇7款外观迷人的HTML5/CSS3 3D按钮特效文章中就收藏了不少。这次我们要带来一款也是基于CSS3的3D按钮，它有着复古的风格和字体。第一个按钮根据光标在悬停时的位置向左或向右倾斜，它的风格类似于老式游戏机按钮。 这些按钮配置了sm，md，lg大小类以及bootstrap-esque类，如primary，secondary，dangerous，warning，success和info。第二个按钮是一个加载程序按钮，按下它时会有自己的进度条。 它只会向中心推动，但随后向上打开，在它的正面显示一个进度条。 根据操作的成功与否，它将在完成时显示具体信息。\r\n![](/Blog/static/pic/1554802460603.png)\r\n链接：\r\n[https://www.html5tricks.com/download/css3-3d-retro-button.rar](https://www.html5tricks.com/download/css3-3d-retro-button.rar \"https://www.html5tricks.com/download/css3-3d-retro-button.rar\")\r\n\r\n# 基于CSS3的iOS风格开关切换按钮\r\n之前我们为大家分享过一些外观富有创意而且实用的CSS3开关切换按钮，比如这个纯CSS3表情切换样式的开关切换按钮和多组超具创意的CSS3开关切换按钮。这次我们带来另外一款基于CSS3的iOS风格开关切换按钮，它的样式是iOS风格的，其中一个特点是你不能同时选中这3项。\r\n![](/Blog/static/pic/1554802501974.png)\r\n链接:\r\n[https://www.html5tricks.com/download/css3-ios-switch-button.rar](https://www.html5tricks.com/download/css3-ios-switch-button.rar \"https://www.html5tricks.com/download/css3-ios-switch-button.rar\")\r\n\r\n# Echarts数据管理图表界面 多种图表使用示例\r\n早些时候，我们给大家分享过一款基于Echarts的HTML5 Canvas中国地图，非常实用。这次我们继续给大家带来一些基于Echarts的数据管理图表界面，这个界面包含很多基于Echarts的图表示例，有柱形图、饼图和地图等。\r\n![](/Blog/static/pic/1554802562535.png)\r\n链接:\r\n[https://www.html5tricks.com/download/echarts-data-graphic.rar](https://www.html5tricks.com/download/echarts-data-graphic.rar \"https://www.html5tricks.com/download/echarts-data-graphic.rar\")\r\n\r\n# CSS3根据渐变序列猜颜色游戏\r\n今天给大家分享一个基于CSS3和JavaScript的颜色辨析游戏，已知3个一组的方块，前面2个方块涂有相近的两种颜色，你根据这两种颜色序列的递减情况，猜测第三个方块的颜色是什么，并从下面的方块中选择你认为最接近的颜色，一起来测试一下自己的辨色能力吧。\r\n![](/Blog/static/pic/1554802603858.png)\r\n链接:\r\n[https://www.html5tricks.com/download/color-sequence.rar](https://www.html5tricks.com/download/color-sequence.rar \"https://www.html5tricks.com/download/color-sequence.rar\")\r\n\r\n', '<h1 id=\"h1-vuejs-\"><a name=\"VueJS表头固定的数据表格 可按每列排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>VueJS表头固定的数据表格 可按每列排序</h1><p>在网页中，表格（table）大部分用于数据的展示和处理，在jQuery的时代，用于表格的插件非常多。今天我们介绍一个基于VueJS的表格应用，它的特点是表格表头固定，也就是说当表格数据行很多时，页面下拉时表头可以固定，方便查看每一列的数据。另外还有特点是我们可以对每一个列进行排序。同时，这款JS表格的外观也不错，可以很好用到你的项目中。VueJS还是挺灵活的。<br><img src=\"/Blog/static/pic/1554802177854.png\" alt=\"\"><br>链接：<a href=\"https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar\" title=\"https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar\">https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar</a></p>\r\n<h1 id=\"h1--three-js-html5-canvas-3d-\"><a name=\"基于Three.js和HTML5 Canvas的3D水晶球体\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基于Three.js和HTML5 Canvas的3D水晶球体</h1><p>今天给大家分享一个很酷的HTML5 Canvas 3D动画，它同样是一个基于Three.js制作的动画特效。在Canvas上有一个用许多长度各异的水晶柱形组成的球体，我们还可以用鼠标拖拽球体来从不同角度观察球面，还可以用鼠标滚轮来缩放球面。还有一个特性就是，双击球面可以改变水晶面的颜色，同时水晶面上会随着旋转的角度出现亮光，更加凸显出其3D立体的视觉效果。<br><img src=\"/Blog/static/pic/1554802278738.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar\" title=\"https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar\">https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar</a></p>\r\n<h1 id=\"h1-html5-emoji-\"><a name=\"HTML5 Emoji自定义表情编辑器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTML5 Emoji自定义表情编辑器</h1><p>Emoji表情在网页中使用十分广泛，它由一些简单的字符组成许多表情，例如笑脸、蛋糕等。今天我们要介绍一个基于HTML5和CSS3的Emoji自定义表情编辑器，初始默认是一个人脸，你可以在编辑器中为该人脸表情添加和改变各种面部表情，例如带上帽子，噘嘴等，甚至可以将其他任意Emoji表情添加上去，用起来非常不错。但是如果可以将编辑好的表情导出就更加完美了。<br><img src=\"/Blog/static/pic/1554802322011.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/html5-emoji-editor.rar\" title=\"https://www.html5tricks.com/download/html5-emoji-editor.rar\">https://www.html5tricks.com/download/html5-emoji-editor.rar</a></p>\r\n<h1 id=\"h1-html5-css3-3d-\"><a name=\"HTML5和CSS3实现的自定义3D滑杆控件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTML5和CSS3实现的自定义3D滑杆控件</h1><p>之前我们分享过一些比较有意思的滑杆控件，比如这款基于VueJS的滑块组件就非常不错。滑杆这种控件一般用在范围选取上面，比如结合图表生成一定范围的数据。今天我们分享的这个滑杆控件自定义程度非常高，特别是使用了CSS3的3D特性，让整一个滑杆控件效果更加炫酷。<br><img src=\"/Blog/static/pic/1554802370966.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/html5-css3-3d-slider.rar\" title=\"https://www.html5tricks.com/download/html5-css3-3d-slider.rar\">https://www.html5tricks.com/download/html5-css3-3d-slider.rar</a></p>\r\n<h1 id=\"h1-css3-svg-\"><a name=\"CSS3和SVG实现的圆环菜单动画\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CSS3和SVG实现的圆环菜单动画</h1><p>网页菜单的样式真实多种多样，特别是HTML5和CSS3的流行，让网页菜单的外观更加丰富多彩了。今天我们要给大家分享一个基于CSS3和SVG的圆环形状的菜单，在圆环上一共有7个节点，表示菜单项，当鼠标滑过或者点击其中一个节点时，就会弹出文字菜单项，圆环形状和节点都是采用SVG绘制而成，动画效果也非常不错。<br><img src=\"/Blog/static/pic/1554802423628.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/css3-svg-circle-menu.rar\" title=\"https://www.html5tricks.com/download/css3-svg-circle-menu.rar\">https://www.html5tricks.com/download/css3-svg-circle-menu.rar</a></p>\r\n<h1 id=\"h1--css3-3d-\"><a name=\"超酷的CSS3复古风格和字体的3D按钮\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>超酷的CSS3复古风格和字体的3D按钮</h1><p>我们分享过很多基于CSS3的3D按钮，很多都非常漂亮，例如这篇7款外观迷人的HTML5/CSS3 3D按钮特效文章中就收藏了不少。这次我们要带来一款也是基于CSS3的3D按钮，它有着复古的风格和字体。第一个按钮根据光标在悬停时的位置向左或向右倾斜，它的风格类似于老式游戏机按钮。 这些按钮配置了sm，md，lg大小类以及bootstrap-esque类，如primary，secondary，dangerous，warning，success和info。第二个按钮是一个加载程序按钮，按下它时会有自己的进度条。 它只会向中心推动，但随后向上打开，在它的正面显示一个进度条。 根据操作的成功与否，它将在完成时显示具体信息。<br><img src=\"/Blog/static/pic/1554802460603.png\" alt=\"\"><br>链接：<br><a href=\"https://www.html5tricks.com/download/css3-3d-retro-button.rar\" title=\"https://www.html5tricks.com/download/css3-3d-retro-button.rar\">https://www.html5tricks.com/download/css3-3d-retro-button.rar</a></p>\r\n<h1 id=\"h1--css3-ios-\"><a name=\"基于CSS3的iOS风格开关切换按钮\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基于CSS3的iOS风格开关切换按钮</h1><p>之前我们为大家分享过一些外观富有创意而且实用的CSS3开关切换按钮，比如这个纯CSS3表情切换样式的开关切换按钮和多组超具创意的CSS3开关切换按钮。这次我们带来另外一款基于CSS3的iOS风格开关切换按钮，它的样式是iOS风格的，其中一个特点是你不能同时选中这3项。<br><img src=\"/Blog/static/pic/1554802501974.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/css3-ios-switch-button.rar\" title=\"https://www.html5tricks.com/download/css3-ios-switch-button.rar\">https://www.html5tricks.com/download/css3-ios-switch-button.rar</a></p>\r\n<h1 id=\"h1-echarts-\"><a name=\"Echarts数据管理图表界面 多种图表使用示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Echarts数据管理图表界面 多种图表使用示例</h1><p>早些时候，我们给大家分享过一款基于Echarts的HTML5 Canvas中国地图，非常实用。这次我们继续给大家带来一些基于Echarts的数据管理图表界面，这个界面包含很多基于Echarts的图表示例，有柱形图、饼图和地图等。<br><img src=\"/Blog/static/pic/1554802562535.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/echarts-data-graphic.rar\" title=\"https://www.html5tricks.com/download/echarts-data-graphic.rar\">https://www.html5tricks.com/download/echarts-data-graphic.rar</a></p>\r\n<h1 id=\"h1-css3-\"><a name=\"CSS3根据渐变序列猜颜色游戏\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CSS3根据渐变序列猜颜色游戏</h1><p>今天给大家分享一个基于CSS3和JavaScript的颜色辨析游戏，已知3个一组的方块，前面2个方块涂有相近的两种颜色，你根据这两种颜色序列的递减情况，猜测第三个方块的颜色是什么，并从下面的方块中选择你认为最接近的颜色，一起来测试一下自己的辨色能力吧。<br><img src=\"/Blog/static/pic/1554802603858.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/color-sequence.rar\" title=\"https://www.html5tricks.com/download/color-sequence.rar\">https://www.html5tricks.com/download/color-sequence.rar</a></p>\r\n', 14, 0, 0, 1, 1, '2021-06-08 17:39:53', '2021-06-08 21:01:24', '\\static\\bgpic\\default.png');
INSERT INTO `article` VALUES (32, 1, 'SpringMVC实现ajax上传图片实时预览', '# 前言\r\n本文介绍使用 SpringMVC + ajaxfileupload.js 实现 ajax 上传文件。 先看效果图\r\n![](/Blog/static/pic/1554800492432.gif)\r\n  点击上传文件框，触发上传文件方法，然后后台返回图片的 url，进行显示。\r\n  \r\n# 前台代码\r\n1、add.jsp (或者 html 文件)\r\n```\r\n<input type=\"file\" name=\"file\" id=\"file\" onchange=\"uploadImg()\">\r\n<input type=\"hidden\" name=\"avatar\" id=\"avatar\">\r\n<img src=\"\" alt=\"\" id=\"avatarShow\" width=\"100px\" height=\"100px\">\r\n```\r\n2、引入 jquery 和 ajaxfileupload.js\r\n```\r\n<script src=\"${pageContext.request.contextPath}/static/js/jquery.min.js\"></script>\r\n<script src=\"${pageContext.request.contextPath}/static/js/ajaxfileupload.js\"></script>\r\n```\r\n这里给出 ajaxfileupload.js 下载地址，网上也有下载 这里有个坑，详情看这里 使用ajaxfileupload.js上传文件成功之后，没有执行success方法。\r\n```\r\n<script>\r\n    //ajax提交信息\r\n    function uploadImg() {\r\n        if($(\"#file\").val() != \"\") {\r\n            $.ajaxFileUpload({\r\n                type: \"POST\",\r\n                url:\"${pageContext.request.contextPath}/uploadFile\",\r\n                dataType: \"json\",\r\n                fileElementId:\"file\",  // 文件的id\r\n                success: function(d){\r\n                    if(d.code == 0) {\r\n                        //alert(\"上传成功\");\r\n                        //图片显示\r\n                        $(\"#avatar\").attr(\"value\",d.data.url);\r\n                        $(\"#avatarShow\").attr(\"src\",d.data.url);\r\n                    }\r\n                },\r\n                error: function () {\r\n                    alert(\"上传失败\");\r\n                },\r\n            });\r\n        } else {\r\n            alert(\"请先选择文件\");\r\n        }\r\n    }\r\n\r\n</script>\r\n```\r\n需要放在 上面两个库的后面 注意： ① type 填 post ② 第8行的 dataType 是小写的 json，不要写成大写的啦 ③ 第9行的 fileElementId 填文件框的id ④ 先确保 url 没写错  \r\n\r\n# 后台代码\r\n1、给 maven 添加依赖 ①、首先需要导入 json 的依赖\r\n```\r\n<!-- jackson -->\r\n    <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-databind</artifactId>\r\n      <version>2.5.0</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-core</artifactId>\r\n      <version>2.5.0</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-annotations</artifactId>\r\n      <version>2.5.0</version>\r\n    </dependency>\r\n```\r\n  ②、然后需要上传文件的依赖\r\n  ```\r\n<dependency>\r\n   <groupId>commons-fileupload</groupId>\r\n   <artifactId>commons-fileupload</artifactId>\r\n   <version>1.3.1</version>\r\n </dependency>\r\n <dependency>\r\n   <groupId>commons-io</groupId>\r\n   <artifactId>commons-io</artifactId>\r\n   <version>2.4</version>\r\n </dependency>\r\n ```\r\n  2、spring-mvc.xml\r\n  ```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"\r\n                http://www.springframework.org/schema/beans\r\n                http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\r\n                http://www.springframework.org/schema/context\r\n                http://www.springframework.org/schema/context/spring-context-3.1.xsd\r\n                http://www.springframework.org/schema/mvc\r\n                http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\" >\r\n    <!-- 启用SpringMVC的注解功能,它会自动注册HandlerMapping、HandlerAdapter、ExceptionResolver的相关实例 -->\r\n    <mvc:annotation-driven />\r\n    <!-- SpringMVC的扫描范围 -->\r\n    <context:component-scan base-package=\"com.liuyanzhao.blog.controller\" use-default-filters=\"false\">\r\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\r\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\r\n    </context:component-scan>\r\n    <!-- 用于返回json格式 -->\r\n    <bean id=\"mappingJacksonHttpMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\r\n        <property name=\"supportedMediaTypes\">\r\n            <list>\r\n                <value>application/x-www-form-urlencoded;charset=UTF-8</value>\r\n            </list>\r\n        </property>\r\n    </bean>\r\n    <!-- 完成请求和注解POJO的映射 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\r\n        <property name=\"messageConverters\">\r\n            <list >\r\n                <ref bean=\"mappingJacksonHttpMessageConverter\" />\r\n            </list>\r\n        </property>\r\n    </bean>\r\n    <!-- 配置SpringMVC的视图解析器 -->\r\n    <!-- 其viewClass属性的默认值就是org.springframework.web.servlet.view.JstlView -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /> -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/views/\" />\r\n        <property name=\"suffix\" value=\".jsp\" />\r\n    </bean>\r\n    <!--文件上传-->\r\n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\r\n        <!--设置上传最大尺寸为50MB-->\r\n        <property name=\"maxUploadSize\" value=\"52428800\"/>\r\n        <property name=\"defaultEncoding\" value=\"UTF-8\"/>\r\n        <property name=\"resolveLazily\" value=\"true\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n上面是 spring-mvc.xml 所有的代码 一定要添加 文件上传 那块代码（50-55行） 然后 31-38 行的 对象转成JSON 也要正确     \r\n\r\n3、UploadFileController.java\r\n```\r\npackage com.liuyanzhao.blog.controller;\r\nimport com.liuyanzhao.blog.vo.ResultVO;\r\nimport com.liuyanzhao.blog.vo.UploadFileVO;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\nimport org.springframework.web.multipart.MultipartFile;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Calendar;\r\n@Controller\r\npublic class UploadFileController {\r\n    //上传文件\r\n    @RequestMapping(value = \"/uploadFile\",method = RequestMethod.POST)\r\n    @ResponseBody\r\n    public ResultVO uploadFile(@Param(\"file\")MultipartFile file) throws IOException {\r\n        //本地使用,上传位置\r\n        String rootPath =\"/Users/liuyanzhao/Documents/uploads/\";\r\n        //String rootPath =\"/www/uploads/\";\r\n        //文件的完整名称,如spring.jpeg\r\n        String filename = file.getOriginalFilename();\r\n        //文件名,如spring\r\n        String name = filename.substring(0,filename.indexOf(\".\"));\r\n        //文件后缀,如.jpeg\r\n        String suffix = filename.substring(filename.lastIndexOf(\".\"));\r\n        //创建年月文件夹\r\n        Calendar date = Calendar.getInstance();\r\n        File dateDirs = new File(date.get(Calendar.YEAR)\r\n                + File.separator + (date.get(Calendar.MONTH)+1));\r\n        //目标文件\r\n        File descFile = new File(rootPath+File.separator+dateDirs+File.separator+filename);\r\n        int i = 1;\r\n        //若文件存在重命名\r\n        String newFilename = filename;\r\n        while(descFile.exists()) {\r\n            newFilename = name+\"(\"+i+\")\"+suffix;\r\n            String parentPath = descFile.getParent();\r\n            descFile = new File(parentPath+File.separator+dateDirs+File.separator+newFilename);\r\n            i++;\r\n        }\r\n        //判断目标文件所在的目录是否存在\r\n        if(!descFile.getParentFile().exists()) {\r\n            //如果目标文件所在的目录不存在，则创建父目录\r\n            descFile.getParentFile().mkdirs();\r\n        }\r\n        //将内存中的数据写入磁盘\r\n        file.transferTo(descFile);\r\n        //完整的url\r\n        String fileUrl =  \"/uploads/\"+dateDirs+ \"/\"+newFilename;\r\n        ResultVO resultVO = new ResultVO();\r\n        resultVO.setCode(0);\r\n        resultVO.setMsg(\"成功\");\r\n        UploadFileVO uploadFileVO = new UploadFileVO();\r\n        uploadFileVO.setTitle(filename);\r\n        uploadFileVO.setUrl(fileUrl);\r\n        resultVO.setData(uploadFileVO);\r\n        return resultVO;\r\n    }\r\n}\r\n```\r\n  注意： ① 一定要加  @ResponseBody   注解，加了 @ResponseBody 注解，我们返回的 resultVO 对象会转成 JSON 返回前台。这个依赖于前面说的 spirng-mvc.xml 里的 JSON 配置 ② 返回给前台的 JSON 格式如下 所以我这里封装了对象 resultVO 和 uploadFileVO 具体类下面会给出 ③ 记得要修改第30行的本地路径，这个路径待会儿还要配静态资源映射   4、ResultVO.java 和 UploadFileVO.java ① ResultVO.java\r\n  ```\r\npackage com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:04\r\n */\r\npublic class ResultVO<T> {\r\n    //错误码\r\n    private Integer code;\r\n    //提示信息\r\n    private String msg;\r\n    //返回的具体内容\r\n    private T data;\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n    public void setMsg(String msg) {\r\n        this.msg = msg;\r\n    }\r\n    public T getData() {\r\n        return data;\r\n    }\r\n    public void setData(T data) {\r\n        this.data = data;\r\n    }\r\n}\r\n这里的 T 表示泛型 ② UploadFileVO.java\r\npackage com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:41\r\n */\r\npublic class UploadFileVO {\r\n    private String url;\r\n    private String title;\r\n    public String getUrl() {\r\n        return url;\r\n    }\r\n    public void setUrl(String url) {\r\n        this.url = url;\r\n    }\r\n    public String getTitle() {\r\n        return title;\r\n    }\r\n    public void setTitle(String title) {\r\n        this.title = title;\r\n    }\r\n}\r\n```\r\n因为这里是上传图片，我们需要给前台返回返回一个 文件的URL，所以这里封装一个对象，用来拼接JSON。\r\n\r\n# 设置静态资源映射，用于显示图片\r\n我这里设置上传文件到 /Users/liuyanzhao/Documents/uploads 目录\r\n比如有一张图片的本地路径为\r\n\r\n/Users/liuyanzhao/Documents/uploads/2017/11/2017113021011541.jpg\r\n\r\n我们想让它能在服务器上访问，需要给 Tomcat 配置静态资源映射\r\n\r\n### 方法一、\r\n使用 IDE 配置，比如我使用的是 IntelliJ IDEA 可以在 Tomcat 的配置 Development 里，如图 \r\n![](/Blog/static/pic/1554800894813.jpg)\r\n\r\n### 方法二、\r\n如果你是直接启动本地的 Tomcat，而不是 IDE 的（不太记得 Eclipse 能不能直接设置），可以在 Tomcat 的目录下的 config/server.xml 里\r\n我的是\r\n`/Users/liuyanzhao/Documents/JavaStudy/tomcat/apache-tomcat-7.0.37/conf/server.xml`\r\n\r\n在最后的 </Host> 里添加\r\n```\r\n<!-- 增加的静态资源映射配置 -->\r\n<Context path=\"/uploads\" docBase=\"/Users/liuyanzhao/Documents/uploads\" reloadable=\"true\" crossContext=\"true\"></Context>\r\n```\r\n如图       \r\n![](/Blog/static/pic/1554800966634.jpg)\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>本文介绍使用 SpringMVC + ajaxfileupload.js 实现 ajax 上传文件。 先看效果图<br><img src=\"/Blog/static/pic/1554800492432.gif\" alt=\"\"><br>  点击上传文件框，触发上传文件方法，然后后台返回图片的 url，进行显示。</p>\r\n<h1 id=\"h1-u524Du53F0u4EE3u7801\"><a name=\"前台代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前台代码</h1><p>1、add.jsp (或者 html 文件)</p>\r\n<pre><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; onchange=&quot;uploadImg()&quot;&gt;\r\n&lt;input type=&quot;hidden&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt;\r\n&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;avatarShow&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;\r\n</code></pre><p>2、引入 jquery 和 ajaxfileupload.js</p>\r\n<pre><code>&lt;script src=&quot;${pageContext.request.contextPath}/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;${pageContext.request.contextPath}/static/js/ajaxfileupload.js&quot;&gt;&lt;/script&gt;\r\n</code></pre><p>这里给出 ajaxfileupload.js 下载地址，网上也有下载 这里有个坑，详情看这里 使用ajaxfileupload.js上传文件成功之后，没有执行success方法。</p>\r\n<pre><code>&lt;script&gt;\r\n    //ajax提交信息\r\n    function uploadImg() {\r\n        if($(&quot;#file&quot;).val() != &quot;&quot;) {\r\n            $.ajaxFileUpload({\r\n                type: &quot;POST&quot;,\r\n                url:&quot;${pageContext.request.contextPath}/uploadFile&quot;,\r\n                dataType: &quot;json&quot;,\r\n                fileElementId:&quot;file&quot;,  // 文件的id\r\n                success: function(d){\r\n                    if(d.code == 0) {\r\n                        //alert(&quot;上传成功&quot;);\r\n                        //图片显示\r\n                        $(&quot;#avatar&quot;).attr(&quot;value&quot;,d.data.url);\r\n                        $(&quot;#avatarShow&quot;).attr(&quot;src&quot;,d.data.url);\r\n                    }\r\n                },\r\n                error: function () {\r\n                    alert(&quot;上传失败&quot;);\r\n                },\r\n            });\r\n        } else {\r\n            alert(&quot;请先选择文件&quot;);\r\n        }\r\n    }\r\n\r\n&lt;/script&gt;\r\n</code></pre><p>需要放在 上面两个库的后面 注意： ① type 填 post ② 第8行的 dataType 是小写的 json，不要写成大写的啦 ③ 第9行的 fileElementId 填文件框的id ④ 先确保 url 没写错  </p>\r\n<h1 id=\"h1-u540Eu53F0u4EE3u7801\"><a name=\"后台代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>后台代码</h1><p>1、给 maven 添加依赖 ①、首先需要导入 json 的依赖</p>\r\n<pre><code>&lt;!-- jackson --&gt;\r\n    &lt;dependency&gt;\r\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\r\n      &lt;version&gt;2.5.0&lt;/version&gt;\r\n    &lt;/dependency&gt;\r\n    &lt;dependency&gt;\r\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\r\n      &lt;version&gt;2.5.0&lt;/version&gt;\r\n    &lt;/dependency&gt;\r\n    &lt;dependency&gt;\r\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n      &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\r\n      &lt;version&gt;2.5.0&lt;/version&gt;\r\n    &lt;/dependency&gt;\r\n</code></pre><p>  ②、然后需要上传文件的依赖</p>\r\n<pre><code>&lt;dependency&gt;\r\n   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;\r\n   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;\r\n   &lt;version&gt;1.3.1&lt;/version&gt;\r\n &lt;/dependency&gt;\r\n &lt;dependency&gt;\r\n   &lt;groupId&gt;commons-io&lt;/groupId&gt;\r\n   &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\r\n   &lt;version&gt;2.4&lt;/version&gt;\r\n &lt;/dependency&gt;\r\n</code></pre><p>  2、spring-mvc.xml</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n       xsi:schemaLocation=&quot;\r\n                http://www.springframework.org/schema/beans\r\n                http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\r\n                http://www.springframework.org/schema/context\r\n                http://www.springframework.org/schema/context/spring-context-3.1.xsd\r\n                http://www.springframework.org/schema/mvc\r\n                http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd&quot; &gt;\r\n    &lt;!-- 启用SpringMVC的注解功能,它会自动注册HandlerMapping、HandlerAdapter、ExceptionResolver的相关实例 --&gt;\r\n    &lt;mvc:annotation-driven /&gt;\r\n    &lt;!-- SpringMVC的扫描范围 --&gt;\r\n    &lt;context:component-scan base-package=&quot;com.liuyanzhao.blog.controller&quot; use-default-filters=&quot;false&quot;&gt;\r\n        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\r\n        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&gt;\r\n    &lt;/context:component-scan&gt;\r\n    &lt;!-- 用于返回json格式 --&gt;\r\n    &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;\r\n        &lt;property name=&quot;supportedMediaTypes&quot;&gt;\r\n            &lt;list&gt;\r\n                &lt;value&gt;application/x-www-form-urlencoded;charset=UTF-8&lt;/value&gt;\r\n            &lt;/list&gt;\r\n        &lt;/property&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!-- 完成请求和注解POJO的映射 --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;\r\n        &lt;property name=&quot;messageConverters&quot;&gt;\r\n            &lt;list &gt;\r\n                &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt;\r\n            &lt;/list&gt;\r\n        &lt;/property&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!-- 配置SpringMVC的视图解析器 --&gt;\r\n    &lt;!-- 其viewClass属性的默认值就是org.springframework.web.servlet.view.JstlView --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n        &lt;!-- &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; --&gt;\r\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt;\r\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!--文件上传--&gt;\r\n    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\r\n        &lt;!--设置上传最大尺寸为50MB--&gt;\r\n        &lt;property name=&quot;maxUploadSize&quot; value=&quot;52428800&quot;/&gt;\r\n        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;\r\n        &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt;\r\n    &lt;/bean&gt;\r\n&lt;/beans&gt;\r\n</code></pre><p>上面是 spring-mvc.xml 所有的代码 一定要添加 文件上传 那块代码（50-55行） 然后 31-38 行的 对象转成JSON 也要正确     </p>\r\n<p>3、UploadFileController.java</p>\r\n<pre><code>package com.liuyanzhao.blog.controller;\r\nimport com.liuyanzhao.blog.vo.ResultVO;\r\nimport com.liuyanzhao.blog.vo.UploadFileVO;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\nimport org.springframework.web.multipart.MultipartFile;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Calendar;\r\n@Controller\r\npublic class UploadFileController {\r\n    //上传文件\r\n    @RequestMapping(value = &quot;/uploadFile&quot;,method = RequestMethod.POST)\r\n    @ResponseBody\r\n    public ResultVO uploadFile(@Param(&quot;file&quot;)MultipartFile file) throws IOException {\r\n        //本地使用,上传位置\r\n        String rootPath =&quot;/Users/liuyanzhao/Documents/uploads/&quot;;\r\n        //String rootPath =&quot;/www/uploads/&quot;;\r\n        //文件的完整名称,如spring.jpeg\r\n        String filename = file.getOriginalFilename();\r\n        //文件名,如spring\r\n        String name = filename.substring(0,filename.indexOf(&quot;.&quot;));\r\n        //文件后缀,如.jpeg\r\n        String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;));\r\n        //创建年月文件夹\r\n        Calendar date = Calendar.getInstance();\r\n        File dateDirs = new File(date.get(Calendar.YEAR)\r\n                + File.separator + (date.get(Calendar.MONTH)+1));\r\n        //目标文件\r\n        File descFile = new File(rootPath+File.separator+dateDirs+File.separator+filename);\r\n        int i = 1;\r\n        //若文件存在重命名\r\n        String newFilename = filename;\r\n        while(descFile.exists()) {\r\n            newFilename = name+&quot;(&quot;+i+&quot;)&quot;+suffix;\r\n            String parentPath = descFile.getParent();\r\n            descFile = new File(parentPath+File.separator+dateDirs+File.separator+newFilename);\r\n            i++;\r\n        }\r\n        //判断目标文件所在的目录是否存在\r\n        if(!descFile.getParentFile().exists()) {\r\n            //如果目标文件所在的目录不存在，则创建父目录\r\n            descFile.getParentFile().mkdirs();\r\n        }\r\n        //将内存中的数据写入磁盘\r\n        file.transferTo(descFile);\r\n        //完整的url\r\n        String fileUrl =  &quot;/uploads/&quot;+dateDirs+ &quot;/&quot;+newFilename;\r\n        ResultVO resultVO = new ResultVO();\r\n        resultVO.setCode(0);\r\n        resultVO.setMsg(&quot;成功&quot;);\r\n        UploadFileVO uploadFileVO = new UploadFileVO();\r\n        uploadFileVO.setTitle(filename);\r\n        uploadFileVO.setUrl(fileUrl);\r\n        resultVO.setData(uploadFileVO);\r\n        return resultVO;\r\n    }\r\n}\r\n</code></pre><p>  注意： ① 一定要加  <a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a>   注解，加了 <a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a> 注解，我们返回的 resultVO 对象会转成 JSON 返回前台。这个依赖于前面说的 spirng-mvc.xml 里的 JSON 配置 ② 返回给前台的 JSON 格式如下 所以我这里封装了对象 resultVO 和 uploadFileVO 具体类下面会给出 ③ 记得要修改第30行的本地路径，这个路径待会儿还要配静态资源映射   4、ResultVO.java 和 UploadFileVO.java ① ResultVO.java</p>\r\n<pre><code>package com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:04\r\n */\r\npublic class ResultVO&lt;T&gt; {\r\n    //错误码\r\n    private Integer code;\r\n    //提示信息\r\n    private String msg;\r\n    //返回的具体内容\r\n    private T data;\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n    public void setMsg(String msg) {\r\n        this.msg = msg;\r\n    }\r\n    public T getData() {\r\n        return data;\r\n    }\r\n    public void setData(T data) {\r\n        this.data = data;\r\n    }\r\n}\r\n这里的 T 表示泛型 ② UploadFileVO.java\r\npackage com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:41\r\n */\r\npublic class UploadFileVO {\r\n    private String url;\r\n    private String title;\r\n    public String getUrl() {\r\n        return url;\r\n    }\r\n    public void setUrl(String url) {\r\n        this.url = url;\r\n    }\r\n    public String getTitle() {\r\n        return title;\r\n    }\r\n    public void setTitle(String title) {\r\n        this.title = title;\r\n    }\r\n}\r\n</code></pre><p>因为这里是上传图片，我们需要给前台返回返回一个 文件的URL，所以这里封装一个对象，用来拼接JSON。</p>\r\n<h1 id=\"h1--\"><a name=\"设置静态资源映射，用于显示图片\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置静态资源映射，用于显示图片</h1><p>我这里设置上传文件到 /Users/liuyanzhao/Documents/uploads 目录<br>比如有一张图片的本地路径为</p>\r\n<p>/Users/liuyanzhao/Documents/uploads/2017/11/2017113021011541.jpg</p>\r\n<p>我们想让它能在服务器上访问，需要给 Tomcat 配置静态资源映射</p>\r\n<h3 id=\"h3--\"><a name=\"方法一、\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法一、</h3><p>使用 IDE 配置，比如我使用的是 IntelliJ IDEA 可以在 Tomcat 的配置 Development 里，如图<br><img src=\"/Blog/static/pic/1554800894813.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3--\"><a name=\"方法二、\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法二、</h3><p>如果你是直接启动本地的 Tomcat，而不是 IDE 的（不太记得 Eclipse 能不能直接设置），可以在 Tomcat 的目录下的 config/server.xml 里<br>我的是<br><code>/Users/liuyanzhao/Documents/JavaStudy/tomcat/apache-tomcat-7.0.37/conf/server.xml</code></p>\r\n<p>在最后的 &lt;/Host&gt; 里添加</p>\r\n<pre><code>&lt;!-- 增加的静态资源映射配置 --&gt;\r\n&lt;Context path=&quot;/uploads&quot; docBase=&quot;/Users/liuyanzhao/Documents/uploads&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;&gt;&lt;/Context&gt;\r\n</code></pre><p>如图<br><img src=\"/Blog/static/pic/1554800966634.jpg\" alt=\"\"></p>\r\n<hr>\r\n', 63, 1, 0, 1, 1, '2021-06-09 14:15:51', '2021-06-08 21:05:05', '\\static\\bgpic\\default.png');
INSERT INTO `article` VALUES (113, 1, 'jQuery——删除 动态添加的元素的方法', '这两天在写JS，写一个遮罩层的时候发现了一个挺有意思的地方，就是直接运用jQ的$选择器的时候无法选择出动态创建的元素，因此也就无法做到删除这个动态添加的元素。然后找寻了各种方法，目前找到两种我觉得是挺好的解决办法。\r\n\r\n先看看我最初写的源代码\r\nHTML：只对一个DIV操作。查找按钮是用来做触发事件的。ID为mask的DIV是拿来当做遮罩层的。\r\n```\r\n<form class=\"search\">\r\n    <input type=\"text\" class=\"input-text\">\r\n    <input type=\"button\" class=\"input-button\" value=\"查找\">\r\n</form>\r\n<!-- <div id=\"mask\"></div> -->\r\n```\r\nCSS：\r\n```\r\n#mask{\r\n    position: absolute;\r\n    z-index: 100!important;\r\n    left: 0;\r\n    top: 0;\r\n    height: 1000px;\r\n    width: 100%;\r\n    background-color: #000;\r\n    opacity: 0.75;\r\n    filter: alpha(opacity = 75);\r\n}\r\n```\r\nJS:\r\n```\r\n$(document).ready(function () {\r\n    var _mask=$(\"<div id=\'mask\'></div>\");\r\n    // 点击按钮创建遮罩层\r\n    $(\".input-button\").click(function(){\r\n        $(_mask).appendTo(\"body\");      \r\n    });\r\n    // 点击遮罩层时删除遮罩层\r\n    $(\"#mask\").click(function(){\r\n        $(this).remove();\r\n    })\r\n});\r\n```\r\n以上代码看似能够实现我们的功能，但是实际上，当你点击遮罩层的时候，并不会删除遮罩层。因为遮罩层是我们点击查找按钮的时候动态创建的，所以直接靠$(\"#mask\")是无法选择出这种动态创建的元素的，自然也就没有作用了。\r\n\r\n# 第一种办法\r\n1. 函数封装\r\n我们可以将$(\"#mask\")这个选择器和动态创建元素的方法封装到一个函数中，然后在创建遮罩层的功能中引用这个函数，就能实现JQ识别出这个动态创建的元素。\r\n\r\n代码如下-JS：\r\n```\r\n// 将方法封装进一个叫做mask的函数中\r\nfunction mask(){\r\n    var _mask=$(\"<div id=\'mask\'></div>\");\r\n    $(_mask).appendTo(\"body\");\r\n    $(\"#mask\").click(function(){\r\n        $(this).remove();\r\n})\r\n};\r\n\r\n// 点击按钮创建遮罩层时调用这个函数\r\n$(\".input-button\").click(function(){\r\n    mask();\r\n    return false;\r\n});\r\n```\r\n# 第二种办法\r\n1. 使用jQuery的on()方法\r\njQuery在1.9版本之后取消了live()方法，所以对于原先用live()实现的方法现在改用on()方法。PS:同时on()方法还能够取代bind()、delegate()方法，也是官方推荐的一种方法。\r\n\r\n先说明一下live()方法。引用W3School的定义：\r\n\r\n>live() 方法为被选元素附加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。\r\n通过 live() 方法附加的事件处理程序适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。\r\n\r\n注意第二句，\r\n\r\n>适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。\r\n\r\n因此live()方法可以用于选择动态创建的元素。在使用1.9以后版本的jQuery时，用on()方法来代替。\r\n\r\non()的用法：`$(selector).on(event,childSelector,data,function,map)`\r\n\r\n当其他选项没有参数时，我们可以忽略它们。这里我们关注三个选项。event：事件，childSelector：子选择器，function：功能。\r\n让on()产生live()相同的功能时，$(selector)里的selector要写成document,也就是绑定整个页面元素。这点很关键，通过页面元素去选择childSelector，即当页面元素的子元素有变化时，该方法能够实时选择出你想要的那个子元素，也就实现了动态选择。而event我们这里是点击，也就是click。至于function，看如下代码：\r\n```\r\nvar _mask=$(\"<div id=\'mask\'></div>\");\r\n// 点击按钮创建遮罩层\r\n$(\".input-button\").click(function(){\r\n    $(_mask).appendTo(\"body\");\r\n});\r\n// 点击遮罩层时删除遮罩层，注意采用了on()方法。\r\n$(document).on(\"click\",\"#mask\",function(){\r\n    $(this).remove();\r\n});\r\n```\r\n\r\n------------\r\n\r\n\r\n在写的时候我貌似发现原生JS由于获取元素id就是通过document.getElementById()的方法也就是直接从document里获取，貌似也不会出现选择不了动态创建元素的情况。这点以后仔细研究后再更新吧。', '<p>这两天在写JS，写一个遮罩层的时候发现了一个挺有意思的地方，就是直接运用jQ的$选择器的时候无法选择出动态创建的元素，因此也就无法做到删除这个动态添加的元素。然后找寻了各种方法，目前找到两种我觉得是挺好的解决办法。</p>\r\n<p>先看看我最初写的源代码<br>HTML：只对一个DIV操作。查找按钮是用来做触发事件的。ID为mask的DIV是拿来当做遮罩层的。</p>\r\n<pre><code>&lt;form class=&quot;search&quot;&gt;\r\n    &lt;input type=&quot;text&quot; class=&quot;input-text&quot;&gt;\r\n    &lt;input type=&quot;button&quot; class=&quot;input-button&quot; value=&quot;查找&quot;&gt;\r\n&lt;/form&gt;\r\n&lt;!-- &lt;div id=&quot;mask&quot;&gt;&lt;/div&gt; --&gt;\r\n</code></pre><p>CSS：</p>\r\n<pre><code>#mask{\r\n    position: absolute;\r\n    z-index: 100!important;\r\n    left: 0;\r\n    top: 0;\r\n    height: 1000px;\r\n    width: 100%;\r\n    background-color: #000;\r\n    opacity: 0.75;\r\n    filter: alpha(opacity = 75);\r\n}\r\n</code></pre><p>JS:</p>\r\n<pre><code>$(document).ready(function () {\r\n    var _mask=$(&quot;&lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;&quot;);\r\n    // 点击按钮创建遮罩层\r\n    $(&quot;.input-button&quot;).click(function(){\r\n        $(_mask).appendTo(&quot;body&quot;);      \r\n    });\r\n    // 点击遮罩层时删除遮罩层\r\n    $(&quot;#mask&quot;).click(function(){\r\n        $(this).remove();\r\n    })\r\n});\r\n</code></pre><p>以上代码看似能够实现我们的功能，但是实际上，当你点击遮罩层的时候，并不会删除遮罩层。因为遮罩层是我们点击查找按钮的时候动态创建的，所以直接靠$(“#mask”)是无法选择出这种动态创建的元素的，自然也就没有作用了。</p>\r\n<h1 id=\"h1-u7B2Cu4E00u79CDu529Eu6CD5\"><a name=\"第一种办法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第一种办法</h1><ol>\r\n<li>函数封装<br>我们可以将$(“#mask”)这个选择器和动态创建元素的方法封装到一个函数中，然后在创建遮罩层的功能中引用这个函数，就能实现JQ识别出这个动态创建的元素。</li></ol>\r\n<p>代码如下-JS：</p>\r\n<pre><code>// 将方法封装进一个叫做mask的函数中\r\nfunction mask(){\r\n    var _mask=$(&quot;&lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;&quot;);\r\n    $(_mask).appendTo(&quot;body&quot;);\r\n    $(&quot;#mask&quot;).click(function(){\r\n        $(this).remove();\r\n})\r\n};\r\n\r\n// 点击按钮创建遮罩层时调用这个函数\r\n$(&quot;.input-button&quot;).click(function(){\r\n    mask();\r\n    return false;\r\n});\r\n</code></pre><h1 id=\"h1-u7B2Cu4E8Cu79CDu529Eu6CD5\"><a name=\"第二种办法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第二种办法</h1><ol>\r\n<li>使用jQuery的on()方法<br>jQuery在1.9版本之后取消了live()方法，所以对于原先用live()实现的方法现在改用on()方法。PS:同时on()方法还能够取代bind()、delegate()方法，也是官方推荐的一种方法。</li></ol>\r\n<p>先说明一下live()方法。引用W3School的定义：</p>\r\n<blockquote>\r\n<p>live() 方法为被选元素附加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。<br>通过 live() 方法附加的事件处理程序适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。</p>\r\n</blockquote>\r\n<p>注意第二句，</p>\r\n<blockquote>\r\n<p>适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。</p>\r\n</blockquote>\r\n<p>因此live()方法可以用于选择动态创建的元素。在使用1.9以后版本的jQuery时，用on()方法来代替。</p>\r\n<p>on()的用法：<code>$(selector).on(event,childSelector,data,function,map)</code></p>\r\n<p>当其他选项没有参数时，我们可以忽略它们。这里我们关注三个选项。event：事件，childSelector：子选择器，function：功能。<br>让on()产生live()相同的功能时，$(selector)里的selector要写成document,也就是绑定整个页面元素。这点很关键，通过页面元素去选择childSelector，即当页面元素的子元素有变化时，该方法能够实时选择出你想要的那个子元素，也就实现了动态选择。而event我们这里是点击，也就是click。至于function，看如下代码：</p>\r\n<pre><code>var _mask=$(&quot;&lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;&quot;);\r\n// 点击按钮创建遮罩层\r\n$(&quot;.input-button&quot;).click(function(){\r\n    $(_mask).appendTo(&quot;body&quot;);\r\n});\r\n// 点击遮罩层时删除遮罩层，注意采用了on()方法。\r\n$(document).on(&quot;click&quot;,&quot;#mask&quot;,function(){\r\n    $(this).remove();\r\n});\r\n</code></pre><hr>\r\n<p>在写的时候我貌似发现原生JS由于获取元素id就是通过document.getElementById()的方法也就是直接从document里获取，貌似也不会出现选择不了动态创建元素的情况。这点以后仔细研究后再更新吧。</p>\r\n', 122, 2, 0, 1, 1, '2021-06-08 14:06:13', '2021-06-08 13:55:13', '\\static\\bgpic\\default.png');

-- ----------------------------
-- Table structure for article_category_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_category_ref`;
CREATE TABLE `article_category_ref`  (
  `article_id` int NULL DEFAULT NULL,
  `category_id` int NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_category_ref
-- ----------------------------
INSERT INTO `article_category_ref` VALUES (30, 55);
INSERT INTO `article_category_ref` VALUES (16, 1);
INSERT INTO `article_category_ref` VALUES (16, 5);
INSERT INTO `article_category_ref` VALUES (17, 1);
INSERT INTO `article_category_ref` VALUES (17, 4);
INSERT INTO `article_category_ref` VALUES (113, 1);
INSERT INTO `article_category_ref` VALUES (113, 8);
INSERT INTO `article_category_ref` VALUES (28, 56);
INSERT INTO `article_category_ref` VALUES (29, 54);
INSERT INTO `article_category_ref` VALUES (32, 1);
INSERT INTO `article_category_ref` VALUES (32, 2);
INSERT INTO `article_category_ref` VALUES (32, 8);
INSERT INTO `article_category_ref` VALUES (32, 9);
INSERT INTO `article_category_ref` VALUES (196, 54);

-- ----------------------------
-- Table structure for article_tag_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_tag_ref`;
CREATE TABLE `article_tag_ref`  (
  `article_id` int NOT NULL,
  `tag_id` int NOT NULL,
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_tag_ref
-- ----------------------------
INSERT INTO `article_tag_ref` VALUES (16, 1);
INSERT INTO `article_tag_ref` VALUES (16, 17);
INSERT INTO `article_tag_ref` VALUES (16, 52);
INSERT INTO `article_tag_ref` VALUES (17, 1);
INSERT INTO `article_tag_ref` VALUES (17, 51);
INSERT INTO `article_tag_ref` VALUES (28, 47);
INSERT INTO `article_tag_ref` VALUES (29, 46);
INSERT INTO `article_tag_ref` VALUES (30, 42);
INSERT INTO `article_tag_ref` VALUES (30, 45);
INSERT INTO `article_tag_ref` VALUES (32, 1);
INSERT INTO `article_tag_ref` VALUES (32, 12);
INSERT INTO `article_tag_ref` VALUES (113, 45);
INSERT INTO `article_tag_ref` VALUES (196, 1);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `category_id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `category_pid` int NULL DEFAULT 0,
  `category_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `category_description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `category_order` int UNSIGNED NULL DEFAULT 1,
  `category_icon` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`category_id`) USING BTREE,
  UNIQUE INDEX `category_name`(`category_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 71 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (1, 0, 'Java', 'Java语言', 1, 'fa fa-coffee');
INSERT INTO `category` VALUES (2, 1, 'Java基础', 'Java相关分类', 2, '');
INSERT INTO `category` VALUES (4, 1, '多线程并发编程', '多线程以及并发相关', 1, '');
INSERT INTO `category` VALUES (7, 1, 'JVM', '虚拟机相关', 1, '');
INSERT INTO `category` VALUES (8, 1, 'JavaWeb', 'Java网页相关', 1, '');
INSERT INTO `category` VALUES (9, 1, 'Java框架', 'Java框架知识', 1, '');
INSERT INTO `category` VALUES (10, 0, '计算机科学', '计算机科学父目录', 1, 'fa fa-cubes');
INSERT INTO `category` VALUES (12, 10, '操作系统', '操作系统', 1, '');
INSERT INTO `category` VALUES (13, 10, '数据库', '数据库系统原理', 1, '');
INSERT INTO `category` VALUES (14, 10, '计算机网络', '计算机网络知识', 1, '');
INSERT INTO `category` VALUES (53, 1, '设计模式和反射', '计算机的设计模式以及反射模式', NULL, NULL);
INSERT INTO `category` VALUES (54, 0, '笔记', '记录个人笔记相关的', 1, NULL);
INSERT INTO `category` VALUES (55, 0, '前端', '前端的一些知识', 1, NULL);
INSERT INTO `category` VALUES (56, 0, 'Linux', 'linux相关的', 1, NULL);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `comment_pid` int UNSIGNED NULL DEFAULT 0,
  `comment_pname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_article_id` int UNSIGNED NULL DEFAULT NULL,
  `comment_author_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_author_email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_like_count` int NULL DEFAULT 0,
  `comment_avatar_path` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_content` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_ip` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_create_time` datetime(0) NULL DEFAULT NULL,
  `comment_role` int NULL DEFAULT NULL,
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 189 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (180, NULL, NULL, 113, '评论员1', '520985211@qq.com', 0, 'static/pic/comment/1623248849801.jpeg', '文章写的真好！', '0:0:0:0:0:0:0:1', '2021-06-09 14:27:30', 0);
INSERT INTO `comment` VALUES (181, 180, '评论员1', 113, '何翔', NULL, 0, 'static/pic/comment/default.jpg', '谢谢支持！', '0:0:0:0:0:0:0:1', '2021-06-09 14:53:10', 1);
INSERT INTO `comment` VALUES (182, NULL, NULL, 113, 'CrackCode', '123456@qq.com', 0, 'static/pic/comment/default.jpg', '真是一篇实用的文章', '0:0:0:0:0:0:0:1', '2021-06-11 03:46:01', 0);
INSERT INTO `comment` VALUES (183, 182, 'CrackCode', 113, '何翔', NULL, 0, 'static/pic/comment/default.jpg', '谢谢支持，爱你！', '0:0:0:0:0:0:0:1', '2021-06-11 03:46:29', 1);
INSERT INTO `comment` VALUES (184, NULL, NULL, 32, '测试评论', '131313131@qq.com', 1, 'static/pic/comment/default.jpg', '对我帮助很大！', '0:0:0:0:0:0:0:1', '2021-06-17 03:14:57', 0);
INSERT INTO `comment` VALUES (185, 184, '测试评论', 32, '何翔', NULL, 0, 'static/pic/comment/default.jpg', '你来测试就好', '0:0:0:0:0:0:0:1', '2021-06-17 03:19:46', 1);

-- ----------------------------
-- Table structure for log
-- ----------------------------
DROP TABLE IF EXISTS `log`;
CREATE TABLE `log`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `time` datetime(0) NULL DEFAULT NULL COMMENT '操作时间',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '操作类型',
  `detail` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '详情',
  `ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'ip',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 854 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of log
-- ----------------------------
INSERT INTO `log` VALUES (771, '2021-06-16 15:31:55', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (772, '2021-06-16 15:39:20', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (773, '2021-06-16 16:06:18', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (774, '2021-06-16 16:21:26', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (775, '2021-06-16 16:21:37', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (776, '2021-06-16 16:52:04', '添加博客', 'Javaweb大作业', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (777, '2021-06-16 17:02:08', '修改博客', '我编辑了文章', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (778, '2021-06-16 17:11:12', '删除博客', '我编辑了文章', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (779, '2021-06-17 00:51:36', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (780, '2021-06-17 01:12:02', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (781, '2021-06-17 01:26:11', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (782, '2021-06-17 01:59:31', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (783, '2021-06-17 02:29:28', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (784, '2021-06-17 02:29:41', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (785, '2021-06-17 02:33:02', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (786, '2021-06-17 02:34:42', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (787, '2021-06-17 02:34:49', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (788, '2021-06-17 02:37:45', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (789, '2021-06-17 02:39:12', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (790, '2021-06-17 03:01:04', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (791, '2021-06-17 03:19:46', '回复评论', '你来测试就好', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (792, '2021-06-17 03:37:06', '修改我的回复', '你来测试就好', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (793, '2021-06-17 03:46:04', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (794, '2021-06-17 03:46:42', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (795, '2021-06-17 03:54:49', '修改密码', '1234', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (796, '2021-06-17 04:02:59', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (797, '2021-06-17 04:03:12', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (798, '2021-06-17 04:15:04', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (799, '2021-06-17 04:15:14', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (800, '2021-06-17 06:18:31', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (801, '2021-06-17 06:34:36', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (802, '2021-06-17 06:38:08', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (803, '2021-06-17 06:49:25', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (804, '2021-06-17 07:00:14', '添加分类', '测试分类', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (805, '2021-06-17 07:04:41', '修改分类', '测试分类', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (806, '2021-06-17 07:05:17', '删除分类', '测试分类', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (807, '2021-06-17 08:02:56', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (808, '2021-06-17 08:09:28', '添加标签', '测试', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (809, '2021-06-17 08:10:13', '删除标签', '测试', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (810, '2021-06-17 08:13:47', '添加标签', '测试', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (811, '2021-06-17 12:33:25', '退出', '退出登陆', '');
INSERT INTO `log` VALUES (812, '2021-06-17 12:46:21', '退出', '退出登陆', '');
INSERT INTO `log` VALUES (813, '2021-06-17 12:46:55', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (814, '2021-06-17 12:50:52', '添加博客', '测试', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (815, '2021-06-17 12:52:36', '修改博客', '测试', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (816, '2021-06-17 12:52:50', '修改博客', '测爱仕达是的', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (817, '2021-06-17 12:53:21', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (818, '2021-06-17 12:53:31', '修改博客', '测爱仕达是的', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (819, '2021-06-17 12:53:58', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (820, '2021-06-17 12:54:18', '删除博客', '测爱仕达是的', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (821, '2021-06-17 12:54:28', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (822, '2021-06-17 12:54:39', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (823, '2021-06-17 13:00:08', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (824, '2021-06-17 13:06:35', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (825, '2021-06-17 13:09:00', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (826, '2021-06-17 13:12:49', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (827, '2021-06-17 13:14:44', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (828, '2021-06-17 13:16:27', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (829, '2021-06-17 13:16:38', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (830, '2021-06-17 13:21:39', '删除博客', '用git命令行上传本地代码到github，并且修改某个文件后将再将该文件提交', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (831, '2021-06-17 13:22:52', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (832, '2021-06-17 13:24:23', '回复评论', '213131', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (833, '2021-06-17 13:24:34', '修改我的回复', '啊是哒是哒', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (834, '2021-06-17 13:24:51', '删除评论', '1123123133', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (835, '2021-06-17 13:26:24', '删除我的回复', '啊是哒是哒', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (836, '2021-06-17 13:51:04', '修改密码', '123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (837, '2021-06-17 13:53:25', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (838, '2021-06-17 13:53:40', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (839, '2021-06-17 13:54:34', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (840, '2021-06-17 13:55:01', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (841, '2021-06-17 13:55:11', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (842, '2021-06-17 13:56:33', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (843, '2021-06-17 13:56:42', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (844, '2021-06-17 13:57:09', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (845, '2021-06-17 13:57:20', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (846, '2021-06-17 14:06:39', '添加分类', '测试', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (847, '2021-06-17 14:06:56', '修改分类', '测试123123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (848, '2021-06-17 14:07:15', '修改分类', '测试123123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (849, '2021-06-17 14:08:05', '删除分类', '测试123123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (850, '2021-06-17 14:14:26', '添加标签', '12313123123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (851, '2021-06-17 14:14:45', '修改标签', '12313123123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (852, '2021-06-17 14:15:24', '删除标签', '12313123123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES (853, '2021-06-17 14:17:54', '删除标签', 'Java', '0:0:0:0:0:0:0:1');

-- ----------------------------
-- Table structure for page
-- ----------------------------
DROP TABLE IF EXISTS `page`;
CREATE TABLE `page`  (
  `page_id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `page_flag` int NULL DEFAULT NULL,
  `page_tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `image_path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`page_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of page
-- ----------------------------
INSERT INTO `page` VALUES (1, 1, 'Blog Article', '/static/images/default.png');
INSERT INTO `page` VALUES (2, 2, 'Blog Article', '/static/images/default.png');
INSERT INTO `page` VALUES (3, 3, 'Blog Article', '/static/images/default.png');
INSERT INTO `page` VALUES (4, 4, 'Blog Article', '/static/images/default.png');
INSERT INTO `page` VALUES (5, 5, 'Blog Article', '/static/images/default.png');
INSERT INTO `page` VALUES (6, 6, 'Blog Article', '/static/images/default.png');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `tag_id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `font_size` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '20px',
  `font_color` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '#49b1f5',
  PRIMARY KEY (`tag_id`) USING BTREE,
  UNIQUE INDEX `tag_name`(`tag_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 68 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'Java', '20px', '#49b1f5');
INSERT INTO `tag` VALUES (2, '算法', '39px', '#00b1f5');
INSERT INTO `tag` VALUES (3, '数据结构', '40px', '#FFC1C1');
INSERT INTO `tag` VALUES (5, '操作系统', '20px', '#93ece1');
INSERT INTO `tag` VALUES (6, '计算机网络', '25px', '#2520df');
INSERT INTO `tag` VALUES (8, '面试题', '32px', '#00b3f1');
INSERT INTO `tag` VALUES (9, '数据库', '20px', '#273cdd');
INSERT INTO `tag` VALUES (10, 'MySQL', NULL, NULL);
INSERT INTO `tag` VALUES (11, 'Spring', '30px', '#35f21c');
INSERT INTO `tag` VALUES (12, 'SpringMVC', NULL, NULL);
INSERT INTO `tag` VALUES (13, 'MyBatis', NULL, NULL);
INSERT INTO `tag` VALUES (14, 'JVM', NULL, NULL);
INSERT INTO `tag` VALUES (15, '设计模式', NULL, NULL);
INSERT INTO `tag` VALUES (16, '网络编程', NULL, NULL);
INSERT INTO `tag` VALUES (17, 'IO', NULL, NULL);
INSERT INTO `tag` VALUES (18, 'JSP', NULL, NULL);
INSERT INTO `tag` VALUES (19, 'Servlet', NULL, NULL);
INSERT INTO `tag` VALUES (20, 'JavaWeb', NULL, NULL);
INSERT INTO `tag` VALUES (21, 'Hibernate', NULL, NULL);
INSERT INTO `tag` VALUES (22, 'SQL', NULL, NULL);
INSERT INTO `tag` VALUES (24, 'Redis', NULL, NULL);
INSERT INTO `tag` VALUES (25, 'SPA', NULL, NULL);
INSERT INTO `tag` VALUES (28, 'EDAS', '29px', '#25cf12');
INSERT INTO `tag` VALUES (34, 'Jenkins', '52px', '#3755e3');
INSERT INTO `tag` VALUES (37, 'Shiro', '20px', '#87ea57');
INSERT INTO `tag` VALUES (38, 'ssm', '20px', '#49b1f5');
INSERT INTO `tag` VALUES (42, '闲杂', '30px', '#00b1f5');
INSERT INTO `tag` VALUES (45, '前端', '23px', '#000080');
INSERT INTO `tag` VALUES (46, 'Github', '20px', '#93fc03');
INSERT INTO `tag` VALUES (47, 'Linux', '20px', '#26211e');
INSERT INTO `tag` VALUES (48, 'vpn', '20px', '#26211e');
INSERT INTO `tag` VALUES (49, '服务器', '26px', '#212b15');
INSERT INTO `tag` VALUES (50, '正则表达式', '26px', '#212b15');
INSERT INTO `tag` VALUES (51, '多线程', '30px', '#10538f');
INSERT INTO `tag` VALUES (52, 'Socket', '30px', '#63301d');
INSERT INTO `tag` VALUES (61, '测试', '20px', '#26211e');

-- ----------------------------
-- Table structure for upload
-- ----------------------------
DROP TABLE IF EXISTS `upload`;
CREATE TABLE `upload`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of upload
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `user_pass` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `user_nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `page_nickname` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `user_signature` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `user_email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `avatar_path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '/static/images/1623161720847.jpg',
  `markdown_profile` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `html_profile` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `person_tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`user_id`) USING BTREE,
  UNIQUE INDEX `user_name`(`user_name`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', '123', '何翔', '我的博客', '永远做一个正能量满满的阳光Boy！', '172837855@qq.com', '/static/images/1623161720847.jpg', '# 关于自己\r\n![](/Blog/static/pic/1555349119482.jpg)\r\n在读学校：珠海科技学院\r\n学院年级：计算机学院2019级\r\n专业班级：软件工程1903\r\n姓名：何翔\r\n\r\n\r\n', '<h1 id=\"h1-u5173u4E8Eu81EAu5DF1\"><a name=\"关于自己\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于自己</h1><p><img src=\"/Blog/static/pic/1555349119482.jpg\" alt=\"\"><br>在读学校：珠海科技学院<br>学院年级：计算机学院2019级<br>专业班级：软件工程1903<br>姓名：何翔</p>\r\n', '永远阳光');
INSERT INTO `user` VALUES (3, '123', '123', '何小翔', '', '', '123', '/static/images/1623161720847.jpg', '12313', '<p>12313</p>\r\n', '');

-- ----------------------------
-- Table structure for user_likear
-- ----------------------------
DROP TABLE IF EXISTS `user_likear`;
CREATE TABLE `user_likear`  (
  `userid` int NOT NULL,
  `likearid` int NOT NULL,
  PRIMARY KEY (`userid`, `likearid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_likear
-- ----------------------------

-- ----------------------------
-- Table structure for user_report
-- ----------------------------
DROP TABLE IF EXISTS `user_report`;
CREATE TABLE `user_report`  (
  `userid` int NULL DEFAULT NULL,
  `reportarid` int NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_report
-- ----------------------------

-- ----------------------------
-- Table structure for user_starar
-- ----------------------------
DROP TABLE IF EXISTS `user_starar`;
CREATE TABLE `user_starar`  (
  `userid` int NOT NULL,
  `starid` int NOT NULL,
  PRIMARY KEY (`userid`, `starid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_starar
-- ----------------------------
INSERT INTO `user_starar` VALUES (3, 113);

-- ----------------------------
-- Table structure for user_type
-- ----------------------------
DROP TABLE IF EXISTS `user_type`;
CREATE TABLE `user_type`  (
  `userid` int NOT NULL,
  `typeid` int NULL DEFAULT 1,
  PRIMARY KEY (`userid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_type
-- ----------------------------
INSERT INTO `user_type` VALUES (1, 0);
INSERT INTO `user_type` VALUES (3, 1);

-- ----------------------------
-- Table structure for vistor
-- ----------------------------
DROP TABLE IF EXISTS `vistor`;
CREATE TABLE `vistor`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `browser` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `visit_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 254 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of vistor
-- ----------------------------
INSERT INTO `vistor` VALUES (246, '127.0.0.1', '', '2021-06-16 15:18:15');
INSERT INTO `vistor` VALUES (247, '0:0:0:0:0:0:0:1', 'Chrome', '2021-06-16 15:18:21');
INSERT INTO `vistor` VALUES (248, '127.0.0.1', '', '2021-06-17 00:50:49');
INSERT INTO `vistor` VALUES (249, '0:0:0:0:0:0:0:1', 'Chrome', '2021-06-17 00:51:02');
INSERT INTO `vistor` VALUES (250, '127.0.0.1', '', '2021-06-17 06:48:03');
INSERT INTO `vistor` VALUES (251, '0:0:0:0:0:0:0:1', 'Chrome', '2021-06-17 06:48:12');
INSERT INTO `vistor` VALUES (252, '127.0.0.1', '', '2021-06-17 12:25:45');
INSERT INTO `vistor` VALUES (253, '0:0:0:0:0:0:0:1', 'Chrome', '2021-06-17 12:25:52');

SET FOREIGN_KEY_CHECKS = 1;
